<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向SEU的程序可靠性分析技术（PIN、DDG、LLVM）]]></title>
    <url>%2F2018%2F04%2F02%2Fdynamicreliabilityanalysis%2F</url>
    <content type="text"><![CDATA[本文是本人博士课题研究过程中的研究日志和开发日志，记录研究思路、开发过程，以及遇到的坑。 面向SEU的程序可靠性分析技术主要涉及到的工具有：基于PIN的程序动态分析工具，利用python实现的动态依赖图（Dynamic Dependency Graph， DDG）生成工具，基于LLVM的软加固工具。 1 基于PIN的程序动态分析工具坑：进行动态profile时，打印出的static instruction中有遗漏，造成DDG绘制不完整 原因：为了聚焦在分析的代码上，在进行动态插桩时需要进行筛选，通常使用filter，通过指定Routine的名字来进行筛选。但我采用了他人开发的pin-tool中的方式，单独实现了筛选功能，不需要指定Routine的名字，直接筛选位于.text段的二进制程序，排除.init / .fini段的影响。但其中有一种筛选方式，筛掉了没有写入寄存器的指令比如store指令（x86中没有store指令，是以move指令实现的）： 123REG reg = INS_RegW(ins, 0);if(!REG_valid(reg)) return false;]]></content>
      <tags>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逐步实现LLVM下的自动软加固工具]]></title>
    <url>%2F2018%2F03%2F27%2FLLVMlearning%2F</url>
    <content type="text"><![CDATA[指令复算是软件容错的基本方法，自动软加固工具和故障注入工具在软加固研究中几乎必不可少，本文随笔者工作进度，逐步完成一个利用LLVM实现的自动软加固工具。将会记录实现面临的关键技术，及开发过程中遇到的细节问题。 1 如何插入一条指令参考：https://stackoverflow.com/questions/35198935/add-an-llvm-instruction 12345678BasicBlock *B = I-&gt;getParent();if (auto *op = dyn_cast&lt;BinaryOperator&gt;(&amp;*I)) &#123; auto temp = op-&gt;clone(); B-&gt;getInstList().insert(op, temp); temp-&gt;setName(op-&gt;getName()); op-&gt;replaceAllUsesWith(temp); &#125; 其中，I是Instruction，BinaryOperator是Instruction的子类。 各种不同的类型的指令，其插入方式各有不同，上面是针对所有指令的直接clone()，该操作除了没有复制指令所在的位置以外，全部copy原始指令的信息，包括use信息，这是实现复算的最便捷的方式，但我们仍然需要插入一些比对、跳转、函数调用等指令，这些指令大多都提供了相应的Create方法，只要有相应的示例，学习起来并不困难。 CmpInst 12Value *newOp = it-&gt;second;CmpInst *cmp = CmpInst::Create(Instruction::ICmp, CmpInst::ICMP_NE, it-&gt;first, it-&gt;second, "eddi_check", inst); CallInst 无参数的call 12345BB-&gt;getInstList().insertAfter(BB-&gt;begin(),newret);FunctionType *error_handle_func_type = FunctionType::get(Type::getVoidTy(context), false); Constant *error_handling_func = F.getParent()-&gt;getOrInsertFunction("error_handling", error_handle_func_type);CallInst::Create(error_handling_func, "", BB-&gt;begin()); 有参数的call 123456789101112131415std::vector&lt;Type*&gt; parameterVector(1);parameterVector[0] = Type::getInt32Ty(context); //IDArrayRef&lt;Type*&gt; parameterVector_array_ref(parameterVector);FunctionType *exit_func_type = FunctionType::get(Type::getVoidTy(context),parameterVector_array_ref, false); Constant *exit_func = F.getParent()-&gt;getOrInsertFunction("exit", exit_func_type);Value *one = ConstantInt::get(Type::getInt32Ty(context),1);std::vector&lt;Value*&gt; exitArgs;exitArgs.push_back(one);ArrayRef&lt;Value*&gt; exitArgs_array_ref(exitArgs);//Create the FunctionCallInst::Create(exit_func, exitArgs_array_ref, "", BB-&gt;end()); ​ 2 如何识别扫描到的指令的类型参考：https://stackoverflow.com/questions/30250289/how-to-check-the-opcode-of-an-instruction 5down voteaccepted isa is used to check for an existing dirived instruction class. class i.getopcode() could help you to get all the operations information. According to the Inheritance diagram for llvm::Instruction,LLVM internally will divide all the instruction into several different classes, like llvm::BinaryOperator, llvm::CallInst, llvm::CmpInst, etc. But there is no exact operation information for these classes. However, for Instruction::getOpcode(), it will directly get the operation from the llvm::Instruction object. You could refer to Instruction.def for an idea about defination of each instruction. Basically, the opcode will be the exact operations the instruction intends to. Say, for an LLVM IR add. You can use isa&lt;llvm::BinaryOperator&gt;, to know that this is a BinaryOperator. But this is only for what the instruction class it is. If you want to know whether it is an ADD or a SUB. i.getopcode() should be used here. 上面给出了几个很好的总结。 Instruction 有多少子类 在http://llvm.org/doxygen/classllvm_1_1Instruction.html 中，有Instruction的继承关系，可以看到Instruction所有的子类 查询每个指令具体属于的操作码，如对于BinaryOperator，具体是ADD还是SUB https://llvm.org/svn/llvm-project/llvm/trunk/include/llvm/IR/Instruction.def 但目前并不知道如何使用这些信息。 使用isa\确定属于哪个子类，使用i.getopcode()确定是子类中的哪个操作 isa(i) and isa(i) without changing to if (i.getopcode()==…) 3. 如何为指令插入Metadata插入字符串类型，借助MDString类，以下为获取每条指令的操作码的名字 12345Value *Elts[] = &#123; MDString::get(context, inst-&gt;getOpcodeName(inst-&gt;getOpcode()))&#125;;MDNode *Node = MDNode::get(context, Elts);temp-&gt;setMetadata("mxk", Node); 插入数字类型 1234std::vector&lt;Value*&gt; llfiindex(1);llfiindex[0] = ConstantInt::get(Type::getInt64Ty(context), fi_index++);MDNode *mdnode = MDNode::get(context, llfiindex);inst-&gt;setMetadata("mxk", mdnode); 删除一条指令的Metadata 12Instruction *temp = inst-&gt;clone();temp-&gt;setMetadata("llfi_index", NULL); 4. 如何更新复算指令的引用为实现代码复算，我们需要为复算指令增加引用，例如： 12%mul = mul nsw i32 %8, %10 原始指令%mul10 = mul nsw i32 %9, %11 副本指令，其use的数据都要更新为原始指令中use数据的副本 为此，我们需要获取每个每个副本指令中需要更新的use数据的信息。 在llvm中，由于采用SSA，所有的数据只会被赋值一次，而且，在数据结构上，所有的数据指针(Value )都是一个指向该数据的指令(Instruction )，注意：Instruction继承自Value和Use。 所以，解决更新副本指令引用的关键，就是找到每个指令所use的数据的副本数据。我们在每条指令的复算过程中，都将原始数据指针（也就是原始指令指针）与副本数据指针（也就是副本数据指针）之间的映射关系存放到map中，这样，我们只需要找到每个指令的所有引用就足以解决问题了。 在https://www.zhihu.com/question/41999500中，给出了很清晰的关于use-def在llvm中如何存储的描述。 llvm的每条指令都存储了def-use信息，结构如下： 对于一个Instruction inst，可以获取其operator的iterator，并且通过for循环遍历之。 123for (User::op_iterator opIterator = temp-&gt;op_begin(); opIterator != temp-&gt;op_end(); opIterator++) &#123; //....&#125; 同时，Use类中，还有一个方法： 123public: /// Normally Use will just implicitly convert to a Value* that it holds. operator Value*() const &#123; return Val; &#125; 也就是说，Use的值会自动转换成一个Value的指针。 所以，我们可以通过opIterator来获取当前指令的所有引用信息。 实现复算和更新副本指令引用的代码如下： 12345678910111213141516171819202122232425BasicBlock *B = inst-&gt;getParent();Instruction *temp = inst-&gt;clone();temp-&gt;setMetadata("llfi_index", NULL);shadow_value_map.insert(std::make_pair&lt;Value*, Value*&gt;(inst, temp));std::vector&lt;Value*&gt; Elts(1);for (User::op_iterator opIterator = temp-&gt;op_begin(); opIterator != temp-&gt;op_end(); opIterator++) &#123; //Use *newOp = opIterator-&gt;getNext();//the operator's next value should be the duplicated instruction Value *curOp = *opIterator; std::map&lt;Value*, Value*&gt;::iterator it = shadow_value_map.find(curOp); if (it != shadow_value_map.end()) &#123; Value *newOp = it-&gt;second; *opIterator = newOp; Elts.push_back(MDString::get(context, newOp-&gt;getName())); &#125; //*opIterator = *newOp;&#125;MDNode *Node = MDNode::get(context, Elts);temp-&gt;setMetadata("mxk1", Node);B-&gt;getInstList().insertAfter(inst,temp);// inst-&gt;replaceAllUsesWith(temp);temp-&gt;setName(inst-&gt;getName()); 5.复算的范围最佳实践是除了terminitor以外，全部复算，这样就与EDDI算法的核心思想相吻合，即，对所有的指令、寄存器、内存都进行了复算。然而，由于某些指令的执行后果的不确定性，导致这样做会出现一些问题。 landingpad指令 这是LLVM中的异常处理机制，在复算检验实现过程中，曾出现过如下异常信息 12345678910111213141516171819202122232425LandingPadInst not the first non-PHI instruction in the block. %21 = landingpad &#123; i8*, i32 &#125; personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) cleanup, !mxk1 !2, !mxk !64, !numuses !4Broken module found, compilation aborted!0 opt 0x00000000018707fa llvm::sys::PrintStackTrace(_IO_FILE*) + 531 opt 0x0000000001870a8a2 opt 0x00000000018704533 libpthread.so.0 0x00007f3b2999f3904 libc.so.6 0x00007f3b28d58428 gsignal + 565 libc.so.6 0x00007f3b28d5a02a abort + 3626 opt 0x000000000175e9eb7 opt 0x000000000175e69f8 opt 0x0000000001734ff8 llvm::FPPassManager::runOnFunction(llvm::Function&amp;) + 3309 opt 0x000000000173516e llvm::FPPassManager::runOnModule(llvm::Module&amp;) + 12010 opt 0x000000000173546e11 opt 0x0000000001735966 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) + 26212 opt 0x0000000001735b3f llvm::legacy::PassManager::run(llvm::Module&amp;) + 3913 opt 0x00000000008f3828 main + 580414 libc.so.6 0x00007f3b28d43830 __libc_start_main + 24015 opt 0x00000000008e4ef9 _start + 41Stack dump:0. Program arguments: /home/xiaofengwo/llvm/llvm-3.4/build/bin/opt -load /home/xiaofengwo/llvm/ir_sihft_llvm_build/bin/../llvm_passes/llfi-passes.so -insttracepass -maxtrace 250 -o /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-profiling.ll /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll -S 1. Running pass 'Function Pass Manager' on module '/home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll'.2. Running pass 'Module Verifier' on function '@_ZN13kdu_synthesisC2E14kdu_resolutionP20kdu_sample_allocatorbf'Aborted (core dumped) landingpad 貌似只能是每个基本块的第一条non-PHI指令。因此，我们把landingpad暂时移出复算域。 call指令 如果对call指令也进行2遍调用，会在执行的时候报段错误，可能是由于每调用一次都产生两遍副本，对于最底层的函数调用次数过多导致的。 如果对call指令仅调用1遍，而后对其define的副本进行同步，则有可能导致call指令引用的变量所指向的内存单元仅在原始变量中是有效的，即如果call指令所引用的变量是指针，那么调用过call指令后，副本指针所指向的位置可能没有值。但由于副本指针和原始指针指向同一位置，如果有对这块地址的修改操作，恐怕会有问题。 在EDDI算法中，也无法解决call指令的问题，无论是调用之后再进行同步，还是调用call指令2遍，都不能自动化实现对于黑盒函数调用之后的数据一致性问题。 Todo：考虑对函数进行分析，确定函数是否可以被调用2遍的角度，实现真正的EDDI算法。 StoreInst和AllocaInst 在EDDI算法中，应该对二者进行复算，但由于call指令的潜在威胁，暂时无法实现完全的EDDI算法，只能实现针对寄存器的SWIFT算法。StoreInst 和 AllocaInst 指令不参与复算。 然而，目前没有对AllocaInst和CallInst之后的返回值进行复算，这样，仍然有部分变量漏掉了，应该在这些指令之后加入一条赋值指令，但目前没有找到这样的指令，考虑增加一条BinaryOperator指令来完成赋值。 Todo：在AllocaInst和CallInst后加入对返回值的复算。 6. 检查校验对于SWIFT算法，校验点插在StoreInst和CallInst，以及branch指令前。 校验点包括比较和跳转，比较指令比较下一条存储或者函数调用将要用到的变量，跳转指令根据比较结果，选择继续执行还是跳转到最后。 比较指令 比较指令分为ICmpInst和FCmpInst，要按照操作数的类型而调整使用的比较指令类型。 12345678if (it-&gt;first-&gt;getType()-&gt;isIntOrIntVectorTy() || it-&gt;first-&gt;getType()-&gt;isPtrOrPtrVectorTy()) &#123; // if (!isa&lt;llvm::IntegerType&gt;(it-&gt;first-&gt;getType())) &#123; cmp = CmpInst::Create(Instruction::ICmp, CmpInst::ICMP_NE, it-&gt;first, it-&gt;second, "eddi_check", inst);&#125; else &#123; cmp = CmpInst::Create(Instruction::FCmp, CmpInst::FCMP_UNE, it-&gt;first, it-&gt;second, "eddi_check", inst);&#125; 其中，it是操作数的迭代器。 然而，按照以上代码，在对br指令之前的副本变量进行校验的时候，会有部分指令报错 123456789101112131415161718192021222324252627/home/xiaofengwo/llvm/llvm-3.4/build/bin/opt -load /home/xiaofengwo/llvm/ir_sihft_llvm_build/bin/../llvm_passes/llfi-passes.so -insttracepass -maxtrace 250 -o /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-profiling.ll /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll -SInvalid operand types for FCmp instruction %eddi_check24 = fcmp une &#123; i8*, i32 &#125; %lpad.val3, %lpad.val323Invalid operand types for FCmp instruction %eddi_check25 = fcmp une &#123; i8*, i32 &#125; %lpad.val3, %lpad.val323Broken module found, compilation aborted!0 opt 0x00000000018707fa llvm::sys::PrintStackTrace(_IO_FILE*) + 531 opt 0x0000000001870a8a2 opt 0x00000000018704533 libpthread.so.0 0x00007f1b3f3403904 libc.so.6 0x00007f1b3e6f9428 gsignal + 565 libc.so.6 0x00007f1b3e6fb02a abort + 3626 opt 0x000000000175e9eb7 opt 0x000000000175e69f8 opt 0x0000000001734ff8 llvm::FPPassManager::runOnFunction(llvm::Function&amp;) + 3309 opt 0x000000000173516e llvm::FPPassManager::runOnModule(llvm::Module&amp;) + 12010 opt 0x000000000173546e11 opt 0x0000000001735966 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) + 26212 opt 0x0000000001735b3f llvm::legacy::PassManager::run(llvm::Module&amp;) + 3913 opt 0x00000000008f3828 main + 580414 libc.so.6 0x00007f1b3e6e4830 __libc_start_main + 24015 opt 0x00000000008e4ef9 _start + 41Stack dump:0. Program arguments: /home/xiaofengwo/llvm/llvm-3.4/build/bin/opt -load /home/xiaofengwo/llvm/ir_sihft_llvm_build/bin/../llvm_passes/llfi-passes.so -insttracepass -maxtrace 250 -o /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-profiling.ll /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll -S 1. Running pass 'Function Pass Manager' on module '/home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll'.2. Running pass 'Module Verifier' on function '@_ZN13kdu_synthesisC2E14kdu_resolutionP20kdu_sample_allocatorbf'Aborted (core dumped) 这就奇怪了，原本以为CmpInst只有ICmpInst和FCmpInst，但上面这种两种都不适用，就不知道怎么回事了。 只好暂时不管这些特殊的类型。 12345678910if (it-&gt;first-&gt;getType()-&gt;isIntOrIntVectorTy() || it-&gt;first-&gt;getType()-&gt;isPtrOrPtrVectorTy()) &#123; // if (!isa&lt;llvm::IntegerType&gt;(it-&gt;first-&gt;getType())) &#123; cmp = CmpInst::Create(Instruction::ICmp, CmpInst::ICMP_NE, it-&gt;first, it-&gt;second, "eddi_check", inst);&#125; else if (it-&gt;first-&gt;getType()-&gt;isFPOrFPVectorTy()) &#123; cmp = CmpInst::Create(Instruction::FCmp, CmpInst::FCMP_UNE, it-&gt;first, it-&gt;second, "eddi_check", inst);&#125; else &#123; continue;&#125; 跳转指令 插入跳转指令，会导致基本块结构的调整，在同一个pass里面，遍历时由于跳转，会破坏该结构，因此，暂时采用插入校验函数的方法，比较低效。 Todo：后期将加入重新对基本块进行调整的机制。 每次拆分基本块后，重新从头开始扫描指令可以解决问题，但十分低效，需要一种快速调整iterator并指向当前处理指令的方法。 可选的方法： 可用方法 是否已尝试 结果 分析 比对之后，结果存于cmp变量中，插入具有比对功能的函数调用 已尝试 方法简单，不需要重新划分基本块，不存在iterator失效问题，但执行时性能较差且出错窗口较大 比对之后，结果存于cmp变量中，在当前指令拆分基本块，并插入br error_detection指令 已尝试 报错，“Instruction does not dominate all uses!” 每次拆分基本块，会是iterator失效，只能重新获取iterator，效率很低。且函数尾部的error_detection标签所处基本块，原本为unreachable，被某处br到后，原本的ret语句不知为何，报错。 比对之后，结果存于cmp变量中，在当前指令拆分基本块，并插入if-then-else，在then中插入错误处理函数 已尝试 报错 每次拆分基本块，会是iterator失效，只能重新获取iterator，效率很低。该方法看似不会存在问题，但是仍然报错，怀疑是iterator的问题 比对之后，结果存于cmp变量中，在当前指令拆分基本块，并插入if-then-else，在then中插入到error_detection的无条件跳转 已尝试 报错，“Instruction does not dominate all uses!” 看来问题集中在ret指令要dominate all uses上 经过各种测试，问题集中在两个方面： 如何在iterator失效的情况下，相对高效地完成对每条代码的扫描 如何解决Instruction does not dominate all uses!问题 7. 后端编译对软加固代码的影响无论是源代码级软加固还是中间代码级软加固，都面临一个难题，就是后端编译对软加固代码的破坏，这些破坏包括但不限于指令重排，寄存器分配等导致检测点位置，检测点语义（检测的对象）发生变化。后端编译对软加固的影响是巨大的，甚至可以使软加固完全失效。 例如，针对原始代码factorial.c 123456789101112131415#include&lt;stdio.h&gt;main(argc, argv)int argc;char *argv[];&#123; int i,fact, n; n = atoi(argv[1]); fact = 1; for(i=1;i&lt;=n;i++) &#123; fact = fact * i; &#125; printf("%d\n",fact); exit(0);&#125; 其中间代码factorial.ll如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172; ModuleID = &apos;factorial.ll&apos;target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-unknown-linux-gnu&quot;@.str = private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1; Function Attrs: nounwind uwtabledefine i32 @main(i32 %argc, i8** %argv) #0 &#123;entry: %retval = alloca i32, align 4 %argc.addr = alloca i32, align 4 %argv.addr = alloca i8**, align 8 %i = alloca i32, align 4 %fact = alloca i32, align 4 %n = alloca i32, align 4 store i32 0, i32* %retval store i32 %argc, i32* %argc.addr, align 4 store i8** %argv, i8*** %argv.addr, align 8 %0 = load i8*** %argv.addr, align 8 %arrayidx = getelementptr inbounds i8** %0, i64 1 %1 = load i8** %arrayidx, align 8 %call = call i32 (i8*, ...)* bitcast (i32 (...)* @atoi to i32 (i8*, ...)*)(i8* %1) store i32 %call, i32* %n, align 4 store i32 1, i32* %fact, align 4 store i32 1, i32* %i, align 4 br label %for.condfor.cond: ; preds = %for.inc, %entry %2 = load i32* %i, align 4 %3 = load i32* %n, align 4 %cmp = icmp sle i32 %2, %3 br i1 %cmp, label %for.body, label %for.endfor.body: ; preds = %for.cond %4 = load i32* %fact, align 4 %5 = load i32* %i, align 4 %mul = mul nsw i32 %4, %5 store i32 %mul, i32* %fact, align 4 br label %for.incfor.inc: ; preds = %for.body %6 = load i32* %i, align 4 %inc = add nsw i32 %6, 1 store i32 %inc, i32* %i, align 4 br label %for.condfor.end: ; preds = %for.cond %7 = load i32* %fact, align 4 %call1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0), i32 %7) call void @exit(i32 0) #3 unreachablereturn: ; No predecessors! %8 = load i32* %retval ret i32 %8&#125;declare i32 @atoi(...) #1declare i32 @printf(i8*, ...) #1; Function Attrs: noreturndeclare void @exit(i32) #2attributes #0 = &#123; nounwind uwtable &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #2 = &#123; noreturn &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #3 = &#123; noreturn &#125;!llvm.ident = !&#123;!0&#125;!0 = metadata !&#123;metadata !&quot;clang version 3.4 (tags/RELEASE_34/final)&quot;&#125; 经过SWIFT算法软加固后的中间代码factorial_swift.ll如下（忽略其中的profiling）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146; ModuleID = &apos;/home/xiaofengwo/llvm/llvm-workspace/sample_programs/factorial/llfi/a-llfi_index.ll&apos;target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-unknown-linux-gnu&quot;@.str = private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1; Function Attrs: nounwind uwtabledefine i32 @main(i32 %argc, i8** %argv) #0 &#123;entry: %retval = alloca i32, align 4 call void @doProfiling(i32 26) %argc.addr = alloca i32, align 4 call void @doProfiling(i32 26) %argv.addr = alloca i8**, align 8 call void @doProfiling(i32 26) %i = alloca i32, align 4 call void @doProfiling(i32 26) %fact = alloca i32, align 4 call void @doProfiling(i32 26) %n = alloca i32, align 4 call void @doProfiling(i32 26) store i32 0, i32* %retval, !storemark !1 store i32 %argc, i32* %argc.addr, align 4, !storemark !1 store i8** %argv, i8*** %argv.addr, align 8, !storemark !1 %0 = load i8*** %argv.addr, align 8 %1 = load i8*** %argv.addr, align 8, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %arrayidx = getelementptr inbounds i8** %0, i64 1 %arrayidx1 = getelementptr inbounds i8** %1, i64 1, !mxk1 !5, !mxk !6, !numuses !4 call void @doProfiling(i32 29) %2 = load i8** %arrayidx, align 8 %3 = load i8** %arrayidx1, align 8, !mxk1 !7, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %eddi_check = icmp ne i8* %2, %3 call void @check_and_error_handling(i1 %eddi_check) %call = call i32 (i8*, ...)* bitcast (i32 (...)* @atoi to i32 (i8*, ...)*)(i8* %2) call void @doProfiling(i32 49) store i32 %call, i32* %n, align 4, !storemark !1 store i32 1, i32* %fact, align 4, !storemark !1 store i32 1, i32* %i, align 4, !storemark !1 br label %for.condfor.cond: ; preds = %for.inc, %entry %4 = load i32* %i, align 4 %5 = load i32* %i, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %6 = load i32* %n, align 4 %7 = load i32* %n, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %cmp = icmp sle i32 %4, %6 %cmp2 = icmp sle i32 %5, %7, !mxk1 !8, !mxk !9, !numuses !4 call void @doProfiling(i32 46) %eddi_check3 = icmp ne i1 %cmp, %cmp2 call void @check_and_error_handling(i1 %eddi_check3) br i1 %cmp, label %for.body, label %for.endfor.body: ; preds = %for.cond %8 = load i32* %fact, align 4 %9 = load i32* %fact, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %10 = load i32* %i, align 4 %11 = load i32* %i, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %mul = mul nsw i32 %8, %10 %mul4 = mul nsw i32 %9, %11, !mxk1 !8, !mxk !10, !numuses !4 call void @doProfiling(i32 12) %eddi_check5 = icmp ne i32 %mul, %mul4 call void @check_and_error_handling(i1 %eddi_check5) store i32 %mul, i32* %fact, align 4, !storemark !1 br label %for.incfor.inc: ; preds = %for.body %12 = load i32* %i, align 4 %13 = load i32* %i, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %inc = add nsw i32 %12, 1 %inc6 = add nsw i32 %13, 1, !mxk1 !5, !mxk !11, !numuses !4 call void @doProfiling(i32 8) %eddi_check7 = icmp ne i32 %inc, %inc6 call void @check_and_error_handling(i1 %eddi_check7) store i32 %inc, i32* %i, align 4, !storemark !1 br label %for.condfor.end: ; preds = %for.cond %14 = load i32* %fact, align 4 %15 = load i32* %fact, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %eddi_check8 = icmp ne i32 %14, %15 call void @check_and_error_handling(i1 %eddi_check8) %call1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0), i32 %14) call void @doProfiling(i32 49) call void @endProfiling() call void @exit(i32 0) #3 unreachablereturn: ; No predecessors! %16 = load i32* %retval %17 = load i32* %retval, !mxk1 !2, !mxk !3, !numuses !12 call void @doProfiling(i32 27) call void @endProfiling() %eddi_check9 = icmp ne i32 %16, %17 call void @check_and_error_handling(i1 %eddi_check9) ret i32 %16mxk_error_detection: ; No predecessors! call void @error_handling() %eddi_check10 = icmp ne i32 %16, %17 call void @check_and_error_handling(i1 %eddi_check10) ret i32 %16&#125;declare i32 @atoi(...) #1declare i32 @printf(i8*, ...) #1; Function Attrs: noreturndeclare void @exit(i32) #2declare void @doProfiling(i32)declare void @endProfiling()declare void @error_handling()declare void @check_and_error_handling(i1)attributes #0 = &#123; nounwind uwtable &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #2 = &#123; noreturn &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #3 = &#123; noreturn &#125;!llvm.ident = !&#123;!0&#125;!0 = metadata !&#123;metadata !&quot;clang version 3.4 (tags/RELEASE_34/final)&quot;&#125;!1 = metadata !&#123;null, metadata !&quot;store&quot;&#125;!2 = metadata !&#123;null&#125;!3 = metadata !&#123;metadata !&quot;load&quot;&#125;!4 = metadata !&#123;i64 1&#125;!5 = metadata !&#123;null, metadata !&quot;&quot;&#125;!6 = metadata !&#123;metadata !&quot;getelementptr&quot;&#125;!7 = metadata !&#123;null, metadata !&quot;arrayidx1&quot;&#125;!8 = metadata !&#123;null, metadata !&quot;&quot;, metadata !&quot;&quot;&#125;!9 = metadata !&#123;metadata !&quot;icmp&quot;&#125;!10 = metadata !&#123;metadata !&quot;mul&quot;&#125;!11 = metadata !&#123;metadata !&quot;add&quot;&#125;!12 = metadata !&#123;i64 2&#125; 但经过后端编译”llc factorial_swift.ll -o factorial_swift.s”后，得到的汇编代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 .file &quot;a-profiling.ll&quot; .text .globl main .align 16, 0x90 .type main,@functionmain: # @main .cfi_startproc# BB#0: # %entry pushq %rbp.Ltmp3: .cfi_def_cfa_offset 16.Ltmp4: .cfi_offset %rbp, -16 movq %rsp, %rbp.Ltmp5: .cfi_def_cfa_register %rbp pushq %r14 pushq %rbx subq $32, %rsp.Ltmp6: .cfi_offset %rbx, -32.Ltmp7: .cfi_offset %r14, -24 movq %rsi, %rbx movl %edi, %r14d movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $0, -20(%rbp) movl %r14d, -24(%rbp) movq %rbx, -32(%rbp) movl $27, %edi callq doProfiling movl $29, %edi callq doProfiling movq 8(%rbx), %rbx movl $27, %edi callq doProfiling xorl %edi, %edi callq check_and_error_handling xorl %eax, %eax movq %rbx, %rdi callq atoi movl %eax, %ebx movl $49, %edi callq doProfiling movl %ebx, -44(%rbp) movl $1, -40(%rbp) movl $1, -36(%rbp) jmp .LBB0_1 .align 16, 0x90.LBB0_2: # %for.body # in Loop: Header=BB0_1 Depth=1 movl -40(%rbp), %ebx movl $27, %edi callq doProfiling imull -36(%rbp), %ebx movl $27, %edi callq doProfiling movl $12, %edi callq doProfiling xorl %edi, %edi callq check_and_error_handling movl %ebx, -40(%rbp) movl -36(%rbp), %ebx movl $27, %edi callq doProfiling incl %ebx movl $8, %edi callq doProfiling xorl %edi, %edi callq check_and_error_handling movl %ebx, -36(%rbp).LBB0_1: # %for.cond # =&gt;This Inner Loop Header: Depth=1 movl -36(%rbp), %r14d movl $27, %edi callq doProfiling movl -44(%rbp), %ebx movl $27, %edi callq doProfiling movl $46, %edi callq doProfiling xorl %edi, %edi callq check_and_error_handling cmpl %ebx, %r14d jle .LBB0_2# BB#3: # %for.end movl -40(%rbp), %ebx movl $27, %edi callq doProfiling xorl %edi, %edi callq check_and_error_handling movl $.L.str, %edi xorl %eax, %eax movl %ebx, %esi callq printf movl $49, %edi callq doProfiling callq endProfiling xorl %edi, %edi callq exit.Ltmp8: .size main, .Ltmp8-main .cfi_endproc .type .L.str,@object # @.str .section .rodata.str1.1,&quot;aMS&quot;,@progbits,1.L.str: .asciz &quot;%d\n&quot; .size .L.str, 4 .ident &quot;clang version 3.4 (tags/RELEASE_34/final)&quot; .section &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits 其中所有的检测指令，全部变成了毫无意义的比对： 12xorl %edi, %edicallq check_and_error_handling 对上面的代码进行故障注入实验，可以看到，一条错误都检测不出来。 1234567891011121314151617=========================================================Timeout Count: 157Exception Count: 743SDC Count: 481Right Count: 1107Detected Count: 0=========================================================time elapsed: 1.439475=========================================================Real Timeout Count: 770Real Exception Count: 2026Real SDC Count: 2500Real Right Count: 7256Real Detected Count: 0.0=========================================================Total Interval Number: 12552(2488, 8) 该问题普遍存在于软加固领域，以往有研究试图通过差异性变换来减轻后端编译带来的问题，在LLVM中，默认的编译优化会在寄存器分配时会做出如上的改造。不开启编译优化，采用-O0编译选项能够部分解决该问题，但对代码性能会造成较为严重的影响。为解决该问题，需要对后端编译过程，主要是寄存器分配过程进行改造。 采用-O0编译选项编译，经过故障注入后的结果为，可以看到，软加固的效果同样十分不理想： 12345678910111213141516Timeout Count: 91Exception Count: 326SDC Count: 496Right Count: 877Detected Count: 706=========================================================time elapsed: 1.225579=========================================================Real Timeout Count: 418Real Exception Count: 1672Real SDC Count: 1938Real Right Count: 5609Real Detected Count: 1515=========================================================Total Interval Number: 11152(2496, 8) 对于未加固的程序，采用-O0优化（就是无优化）时，动态指令序列为83，故障注入结果为： 123456789101112131415161718192021222324252627282930313233343536=========================================================Timeout Count: 10Exception Count: 199SDC Count: 411Right Count: 236Detected Count: 0=========================================================time elapsed: 0.388901=========================================================Real Timeout Count: 20Real Exception Count: 703Real SDC Count: 652Real Right Count: 1385Real Detected Count: 0.0=========================================================Total Interval Number: 2760(856, 8)=========================================================Timeout Count: 19Exception Count: 208SDC Count: 385Right Count: 244Detected Count: 0=========================================================time elapsed: 0.455671=========================================================Real Timeout Count: 36Real Exception Count: 755Real SDC Count: 562Real Right Count: 1407Real Detected Count: 0.0=========================================================Total Interval Number: 2760(856, 8) 比对汇编代码发现，即便开启-O0，仍然有软加固代码被优化掉的现象： 未加固版的汇编代码： 12345.LBB0_1: # %for.cond # =&gt;This Inner Loop Header: Depth=1 movl -20(%rbp), %eax cmpl -28(%rbp), %eax jg .LBB0_4 加固版汇编代码： 12345678910111213141516.LBB0_1: # %for.cond # =&gt;This Inner Loop Header: Depth=1 movl -20(%rbp), %eax movl -28(%rbp), %ecx subl %ecx, %eax setle %dl xorl %ecx, %ecx movb %cl, %sil movzbl %sil, %edi movl %eax, -44(%rbp) # 4-byte Spill movb %dl, -45(%rbp) # 1-byte Spill callq check_and_error_handling movb -45(%rbp), %dl # 1-byte Reload testb $1, %dl jne .LBB0_2 jmp .LBB0_4 为此，进行了进一步的尝试，将比对 1234567891011121314151617=========================================================Timeout Count: 110Exception Count: 304SDC Count: 483Right Count: 673Detected Count: 998=========================================================time elapsed: 7.668829=========================================================Real Timeout Count: 344Real Exception Count: 1504Real SDC Count: 1793Real Right Count: 4744Real Detected Count: 2447=========================================================Total Interval Number: 10832(2568, 8) Todo： 通过改变寄存器分配方式，减轻后端编译优化对软加固代码的影响。 疑问，是不是通过传参比对就可以避免二者之间的依赖关系了？或者有没有可能解决了前文的基本块拆分问题，就可以阻止此处的寄存器分配导致软加固失效的现象了？ 实验一：将比较指令删除，将原始变量和副本变量的一致性校验功能集成到函数中，通过函数调用避免编译器发现二者之间的关联性，从而为原始变量和副本变量分配相同的寄存器，致使软加固失效。 实验结果总结：即便 factorial_swift.ll 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139; ModuleID = &apos;/home/xiaofengwo/llvm/llvm-workspace/sample_programs/factorial/llfi/a-llfi_index.ll&apos;target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-unknown-linux-gnu&quot;@.str = private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1; Function Attrs: nounwind uwtabledefine i32 @main(i32 %argc, i8** %argv) #0 &#123;entry: %retval = alloca i32, align 4 call void @doProfiling(i32 26) %argc.addr = alloca i32, align 4 call void @doProfiling(i32 26) %argv.addr = alloca i8**, align 8 call void @doProfiling(i32 26) %i = alloca i32, align 4 call void @doProfiling(i32 26) %fact = alloca i32, align 4 call void @doProfiling(i32 26) %n = alloca i32, align 4 call void @doProfiling(i32 26) store i32 0, i32* %retval, !storemark !1 store i32 %argc, i32* %argc.addr, align 4, !storemark !1 store i8** %argv, i8*** %argv.addr, align 8, !storemark !1 %0 = load i8*** %argv.addr, align 8 %1 = load i8*** %argv.addr, align 8, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %arrayidx = getelementptr inbounds i8** %0, i64 1 %arrayidx1 = getelementptr inbounds i8** %1, i64 1, !mxk1 !5, !mxk !6, !numuses !4 call void @doProfiling(i32 29) %2 = load i8** %arrayidx, align 8 %3 = load i8** %arrayidx1, align 8, !mxk1 !7, !mxk !3, !numuses !4 call void @doProfiling(i32 27) call void @check_and_error_handling2(i8* %2, i8* %3) %call = call i32 (i8*, ...)* bitcast (i32 (...)* @atoi to i32 (i8*, ...)*)(i8* %2) call void @doProfiling(i32 49) store i32 %call, i32* %n, align 4, !storemark !1 store i32 1, i32* %fact, align 4, !storemark !1 store i32 1, i32* %i, align 4, !storemark !1 br label %for.condfor.cond: ; preds = %for.inc, %entry %4 = load i32* %i, align 4 %5 = load i32* %i, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %6 = load i32* %n, align 4 %7 = load i32* %n, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %cmp = icmp sle i32 %4, %6 %cmp2 = icmp sle i32 %5, %7, !mxk1 !8, !mxk !9, !numuses !4 call void @doProfiling(i32 46) call void bitcast (void (i8*, i8*)* @check_and_error_handling2 to void (i1, i1)*)(i1 %cmp, i1 %cmp2) br i1 %cmp, label %for.body, label %for.endfor.body: ; preds = %for.cond %8 = load i32* %fact, align 4 %9 = load i32* %fact, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %10 = load i32* %i, align 4 %11 = load i32* %i, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %mul = mul nsw i32 %8, %10 %mul3 = mul nsw i32 %9, %11, !mxk1 !8, !mxk !10, !numuses !4 call void @doProfiling(i32 12) call void bitcast (void (i8*, i8*)* @check_and_error_handling2 to void (i32, i32)*)(i32 %mul, i32 %mul3) store i32 %mul, i32* %fact, align 4, !storemark !1 br label %for.incfor.inc: ; preds = %for.body %12 = load i32* %i, align 4 %13 = load i32* %i, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) %inc = add nsw i32 %12, 1 %inc4 = add nsw i32 %13, 1, !mxk1 !5, !mxk !11, !numuses !4 call void @doProfiling(i32 8) call void bitcast (void (i8*, i8*)* @check_and_error_handling2 to void (i32, i32)*)(i32 %inc, i32 %inc4) store i32 %inc, i32* %i, align 4, !storemark !1 br label %for.condfor.end: ; preds = %for.cond %14 = load i32* %fact, align 4 %15 = load i32* %fact, align 4, !mxk1 !2, !mxk !3, !numuses !4 call void @doProfiling(i32 27) call void bitcast (void (i8*, i8*)* @check_and_error_handling2 to void (i32, i32)*)(i32 %14, i32 %15) %call1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0), i32 %14) call void @doProfiling(i32 49) call void @endProfiling() call void @exit(i32 0) #3 unreachablereturn: ; No predecessors! %16 = load i32* %retval %17 = load i32* %retval, !mxk1 !2, !mxk !3, !numuses !12 call void @doProfiling(i32 27) call void @endProfiling() call void bitcast (void (i8*, i8*)* @check_and_error_handling2 to void (i32, i32)*)(i32 %16, i32 %17) ret i32 %16mxk_error_detection: ; No predecessors! call void @error_handling() call void bitcast (void (i8*, i8*)* @check_and_error_handling2 to void (i32, i32)*)(i32 %16, i32 %17) ret i32 %16&#125;declare i32 @atoi(...) #1declare i32 @printf(i8*, ...) #1; Function Attrs: noreturndeclare void @exit(i32) #2declare void @doProfiling(i32)declare void @endProfiling()declare void @error_handling()declare void @check_and_error_handling2(i8*, i8*)attributes #0 = &#123; nounwind uwtable &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #2 = &#123; noreturn &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #3 = &#123; noreturn &#125;!llvm.ident = !&#123;!0&#125;!0 = metadata !&#123;metadata !&quot;clang version 3.4 (tags/RELEASE_34/final)&quot;&#125;!1 = metadata !&#123;null, metadata !&quot;store&quot;&#125;!2 = metadata !&#123;null&#125;!3 = metadata !&#123;metadata !&quot;load&quot;&#125;!4 = metadata !&#123;i64 1&#125;!5 = metadata !&#123;null, metadata !&quot;&quot;&#125;!6 = metadata !&#123;metadata !&quot;getelementptr&quot;&#125;!7 = metadata !&#123;null, metadata !&quot;arrayidx1&quot;&#125;!8 = metadata !&#123;null, metadata !&quot;&quot;, metadata !&quot;&quot;&#125;!9 = metadata !&#123;metadata !&quot;icmp&quot;&#125;!10 = metadata !&#123;metadata !&quot;mul&quot;&#125;!11 = metadata !&#123;metadata !&quot;add&quot;&#125;!12 = metadata !&#123;i64 2&#125; factorial_swift.s 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 .file &quot;a-profiling.ll&quot; .text .globl main .align 16, 0x90 .type main,@functionmain: # @main .cfi_startproc# BB#0: # %entry pushq %rbp.Ltmp3: .cfi_def_cfa_offset 16.Ltmp4: .cfi_offset %rbp, -16 movq %rsp, %rbp.Ltmp5: .cfi_def_cfa_register %rbp pushq %r15 pushq %r14 pushq %rbx subq $40, %rsp.Ltmp6: .cfi_offset %rbx, -40.Ltmp7: .cfi_offset %r14, -32.Ltmp8: .cfi_offset %r15, -24 movq %rsi, %rbx movl %edi, %r14d movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $0, -28(%rbp) movl %r14d, -32(%rbp) movq %rbx, -40(%rbp) movl $27, %edi callq doProfiling movl $29, %edi callq doProfiling movq 8(%rbx), %rbx movl $27, %edi callq doProfiling movq %rbx, %rdi movq %rbx, %rsi callq check_and_error_handling2 xorl %eax, %eax movq %rbx, %rdi callq atoi movl %eax, %ebx movl $49, %edi callq doProfiling movl %ebx, -52(%rbp) movl $1, -48(%rbp) movl $1, -44(%rbp) jmp .LBB0_1 .align 16, 0x90.LBB0_2: # %for.body # in Loop: Header=BB0_1 Depth=1 movl -48(%rbp), %ebx movl $27, %edi callq doProfiling imull -44(%rbp), %ebx movl $27, %edi callq doProfiling movl $12, %edi callq doProfiling movl %ebx, %edi movl %ebx, %esi callq check_and_error_handling2 movl %ebx, -48(%rbp) movl -44(%rbp), %ebx movl $27, %edi callq doProfiling incl %ebx movl $8, %edi callq doProfiling movl %ebx, %edi movl %ebx, %esi callq check_and_error_handling2 movl %ebx, -44(%rbp).LBB0_1: # %for.cond # =&gt;This Inner Loop Header: Depth=1 movl -44(%rbp), %r14d movl $27, %edi callq doProfiling movl -52(%rbp), %ebx movl $27, %edi callq doProfiling cmpl %ebx, %r14d setle %r15b movl $46, %edi callq doProfiling movzbl %r15b, %edi movl %edi, %esi callq check_and_error_handling2 cmpl %ebx, %r14d jle .LBB0_2# BB#3: # %for.end movl -48(%rbp), %ebx movl $27, %edi callq doProfiling movl %ebx, %edi movl %ebx, %esi callq check_and_error_handling2 movl $.L.str, %edi xorl %eax, %eax movl %ebx, %esi callq printf movl $49, %edi callq doProfiling callq endProfiling xorl %edi, %edi callq exit.Ltmp9: .size main, .Ltmp9-main .cfi_endproc .type .L.str,@object # @.str .section .rodata.str1.1,&quot;aMS&quot;,@progbits,1.L.str: .asciz &quot;%d\n&quot; .size .L.str, 4 .ident &quot;clang version 3.4 (tags/RELEASE_34/final)&quot; .section &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits 可以看出，并没有什么卵用。 偶然一试，发现修改llc编译优化选项似乎有些效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191 .file &quot;a-profiling.ll&quot; .text .globl main .align 16, 0x90 .type main,@functionmain: # @main .cfi_startproc# BB#0: # %entry pushq %rbp.Ltmp2: .cfi_def_cfa_offset 16.Ltmp3: .cfi_offset %rbp, -16 movq %rsp, %rbp.Ltmp4: .cfi_def_cfa_register %rbp subq $176, %rsp movl $26, %eax movl %edi, -32(%rbp) # 4-byte Spill movl %eax, %edi movq %rsi, -40(%rbp) # 8-byte Spill callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $26, %edi callq doProfiling movl $27, %edi movl $0, -4(%rbp) movl -32(%rbp), %eax # 4-byte Reload movl %eax, -8(%rbp) movq -40(%rbp), %rsi # 8-byte Reload movq %rsi, -16(%rbp) movq -16(%rbp), %rcx movq -16(%rbp), %rdx movq %rdx, -48(%rbp) # 8-byte Spill movq %rcx, -56(%rbp) # 8-byte Spill callq doProfiling movl $29, %edi callq doProfiling movl $27, %edi movq -56(%rbp), %rcx # 8-byte Reload movq 8(%rcx), %rdx movq -48(%rbp), %rsi # 8-byte Reload movq 8(%rsi), %rsi movq %rsi, -64(%rbp) # 8-byte Spill movq %rdx, -72(%rbp) # 8-byte Spill callq doProfiling movq -72(%rbp), %rdi # 8-byte Reload movq -64(%rbp), %rsi # 8-byte Reload callq check_and_error_handling2 movl $49, %edi movq -72(%rbp), %rcx # 8-byte Reload movl %edi, -76(%rbp) # 4-byte Spill movq %rcx, %rdi movb $0, %al callq atoi movl -76(%rbp), %edi # 4-byte Reload movl %eax, -80(%rbp) # 4-byte Spill callq doProfiling movl -80(%rbp), %eax # 4-byte Reload movl %eax, -28(%rbp) movl $1, -24(%rbp) movl $1, -20(%rbp).LBB0_1: # %for.cond # =&gt;This Inner Loop Header: Depth=1 movl $27, %edi movl -20(%rbp), %eax movl -20(%rbp), %ecx movl %ecx, -84(%rbp) # 4-byte Spill movl %eax, -88(%rbp) # 4-byte Spill callq doProfiling movl $27, %edi movl -28(%rbp), %eax movl -28(%rbp), %ecx movl %ecx, -92(%rbp) # 4-byte Spill movl %eax, -96(%rbp) # 4-byte Spill callq doProfiling movl $46, %edi movl -88(%rbp), %eax # 4-byte Reload movl -96(%rbp), %ecx # 4-byte Reload cmpl %ecx, %eax setle %dl movl -84(%rbp), %esi # 4-byte Reload movl -92(%rbp), %r8d # 4-byte Reload cmpl %r8d, %esi setle %r9b movb %r9b, -97(%rbp) # 1-byte Spill movb %dl, -98(%rbp) # 1-byte Spill callq doProfiling movb -98(%rbp), %dl # 1-byte Reload movzbl %dl, %edi movb -97(%rbp), %r9b # 1-byte Reload movzbl %r9b, %esi callq check_and_error_handling2 movb -98(%rbp), %dl # 1-byte Reload testb $1, %dl jne .LBB0_2 jmp .LBB0_4.LBB0_2: # %for.body # in Loop: Header=BB0_1 Depth=1 movl $27, %edi movl -24(%rbp), %eax movl -24(%rbp), %ecx movl %ecx, -104(%rbp) # 4-byte Spill movl %eax, -108(%rbp) # 4-byte Spill callq doProfiling movl $27, %edi movl -20(%rbp), %eax movl -20(%rbp), %ecx movl %ecx, -112(%rbp) # 4-byte Spill movl %eax, -116(%rbp) # 4-byte Spill callq doProfiling movl $12, %edi movl -108(%rbp), %eax # 4-byte Reload movl -116(%rbp), %ecx # 4-byte Reload imull %ecx, %eax movl -104(%rbp), %ecx # 4-byte Reload movl -112(%rbp), %edx # 4-byte Reload imull %edx, %ecx movl %ecx, -120(%rbp) # 4-byte Spill movl %eax, -124(%rbp) # 4-byte Spill callq doProfiling movl -124(%rbp), %edi # 4-byte Reload movl -120(%rbp), %esi # 4-byte Reload callq check_and_error_handling2 movl -124(%rbp), %eax # 4-byte Reload movl %eax, -24(%rbp)# BB#3: # %for.inc # in Loop: Header=BB0_1 Depth=1 movl $27, %edi movl -20(%rbp), %eax movl -20(%rbp), %ecx movl %ecx, -128(%rbp) # 4-byte Spill movl %eax, -132(%rbp) # 4-byte Spill callq doProfiling movl $8, %edi movl -132(%rbp), %eax # 4-byte Reload addl $1, %eax movl -128(%rbp), %ecx # 4-byte Reload addl $1, %ecx movl %ecx, -136(%rbp) # 4-byte Spill movl %eax, -140(%rbp) # 4-byte Spill callq doProfiling movl -140(%rbp), %edi # 4-byte Reload movl -136(%rbp), %esi # 4-byte Reload callq check_and_error_handling2 movl -140(%rbp), %eax # 4-byte Reload movl %eax, -20(%rbp) jmp .LBB0_1.LBB0_4: # %for.end movl $27, %edi movl -24(%rbp), %eax movl -24(%rbp), %esi movl %esi, -144(%rbp) # 4-byte Spill movl %eax, -148(%rbp) # 4-byte Spill callq doProfiling leaq .L.str, %rdi movl -148(%rbp), %eax # 4-byte Reload movq %rdi, -160(%rbp) # 8-byte Spill movl %eax, %edi movl -144(%rbp), %esi # 4-byte Reload callq check_and_error_handling2 movq -160(%rbp), %rdi # 8-byte Reload movl -148(%rbp), %esi # 4-byte Reload movb $0, %al callq printf movl $49, %edi movl %eax, -164(%rbp) # 4-byte Spill callq doProfiling callq endProfiling movl $0, %edi callq exit.Ltmp5: .size main, .Ltmp5-main .cfi_endproc .type .L.str,@object # @.str .section .rodata.str1.1,&quot;aMS&quot;,@progbits,1.L.str: .asciz &quot;%d\n&quot; .size .L.str, 4 .ident &quot;clang version 3.4 (tags/RELEASE_34/final)&quot; .section &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits]]></content>
      <tags>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现docx文档的版本管理]]></title>
    <url>%2F2018%2F03%2F18%2Fhowtotrackdocxfilewithgit%2F</url>
    <content type="text"><![CDATA[docx文件提交到git很容易，对docx文件实现版本管理的难点在于如何比较其中的差异，方法简要概述如下： 利用pandoc实现将docx文件转成md文件（只能是docx，而不能是doc） 通过git hook，配置pre-commit和post-commit，在git commit时自动调用生成md文件的过程，并将md文件提交到库中 md文件作为docx的副本，且可以通过diff直接查看 参考：https://github.com/vigente/gerardus/wiki/Integrate-git-diffs-with-word-docx-files 1. 安装pandoc2. Tell git how to handle diffs of .docx files. Create or edit file ~/.gitconfig (linux, Mac) or “c:\Documents and Settings\user.gitconfig” (Windows) to add 12345[diff &quot;pandoc&quot;] textconv=pandoc --to=markdown prompt = false[alias] wdiff = diff --word-diff=color --unified=1 In your paper directory, create or edit file .gitattributes (linux, Windows and Mac) to add 1*.docx diff=pandoc You can commit .gitattributes so that it stays with your paper for use in other computers, but you’ll need to edit ~/.gitconfig in every new computer you want to use. 3. 配置git hookThis is only going to work from linux/Mac or Windows running git from a bash shell. Install pandoc. Pandoc is a program to convert between different file formats. It’s going to allow us to convert Word files (.docx) to Markdown (.md). Set up git hooks to enable automatic generation and tracking of Markdown copies of .docx files. Copy these hook files to your git project’s .git/hooks directory and rename them, or soft-link to them with ln -s, and make them executable (chmod u+x *.sh): pre-commit-git-diff-docx.sh -&gt; .git/hooks/pre-commit post-commit-git-diff-docx.sh -&gt; .git/hooks/post-commit Now every time you run git commit, the pre-commit hook will automatically run before you see the window to enter the log message. The hook is a script that makes a copy in Markdown format (.md) of every .docx file you are committing. The post-commit hook then amends the commit adding the .md files.]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用shadowsocks配置系统代理]]></title>
    <url>%2F2018%2F02%2F06%2Finstruction-to-use-shadowsocks-for-system-proxy%2F</url>
    <content type="text"><![CDATA[1. 配置AWS服务器如果没有搭建远端shadowsocks服务器的需求，可以跳过这一步。 申请AWS账号 登陆AWS官方网站https://aws.amazon.com/cn/，并注册账号，需要填写邮箱号，信用卡信息和手机号码，注册时都会进行验证，信用卡会通过预扣费1美元验证，手机号码通过电话输入屏幕显示的即时数字验证。 现在新注册的用户，需要24小时才能完全激活。 开通EC2实例，不具体展开，但需要注意几个问题： 1）选择标有“符合条件的免费套餐”的系统映像（AMI），最好选择红框中的选项，其它的有时不能上GoogleScholar 2）建议选择新加坡地区，延迟较小。 3）启动EC2实例后，一定要修改安全策略，按照下图中的安全组策略配置出站和入站策略，允许全部来源的全部端口，否则无法接入。 利用MobaXterm或者其它终端访问软件连接用户，需要配置远程ip地址（通过在aws管理页面查看已启动的EC2实例获取）、username（固定写ec2-user）、端口（22），以及private key（在启动EC2的时候会要求下载） 配置远端ShadowSocks服务器 1）安装shadowsocks，在命令行中依次输入： 12345sudo yum install python-gevent python-pipsudo pip install shadowsockssudo vi ~/config.json 注：config.json可以实现编写好，然后上传到远程ec2主机，放在任何位置都可以，只要在引用的时候找得到，最好放在用户的home目录下，这样命令短一些。 填入配置信息： 12345678&#123; "server":"xx.xx.xx.xx", //填写私有IP "server_port":8388, "local_port":10808, "password":"bgt56yhn", "timeout":600, "method":"aes-256-cfb" &#125; 如果需要配置多个端口，则按照下面的格式： 1234567891011&#123; "server":"xx.xx.xx.xx", //填写私有IP "local_port":1080, "port_password": &#123; "8381": "aaa", "8382": "aaa", "8383": "aaa", &#125;, "timeout":600, "method":"aes-256-cfb"&#125; 注意：上面的server属性，需要配置为私有IP，同样在aws页面的ec2 Dashboard下可以查到： 密码和端口自行设置，加密算法注意要与本地ShadowSocks客户端统一。 2）增加开机启动（没有必要，因为远程服务器EC2重启轻易不会关机）： 1sudo vim /etc/rc.local 在结尾增加这句话就可以开机启动了： 1/usr/local/bin/ssserver -c ~/config.json 3）在命令行中启动后台Shadowsocks（不随命令行关闭而结束）： 1nohup ssserver -c ~/config.json &amp; 2. 配置本地ShadowSocks客户端 下载ShadowSocks Shadowsocks-4.0.1.zip 配置ShadowSocks 下载后，打开ShadowSocks客户端，配置远端服务器信息。 启用ShadowSocks客户端 正确启动ShadowSocks客户端以后，就打开了一个本地的代理端口1723，本地应用如果需要使用这个代理，还需要进行一定的配置。除了Chrome以外，其它很多程序也可以配置代理，我们主要讲解Chrome的代理配置。 3. 配置Chrome代理 配置Chrome系统代理 在Chrome设置中找到系统代理设置 这个Chrome的代理设置实际上和IE浏览器的代理设置是共享的，设置方法也一样。 依次点击“连接”——“局域网设置”，按照下图配置代理服务器 配置好以后，Chrome就可以通过代理上网了 配置Chrome自动代理 配置好Chrome系统代理后，Chrome所有的访问都将通过代理服务器，一方面增加服务器的压力，占用带宽和流量，另一方面，很多国内的站点，还通过代理服务器访问，会影响上网速度。 下面我们通过Proxy SwitchyOmega这个Chrome扩展程序，配置Chrome自动切换代理功能。 下载Proxy SwitchyOmega。 这一步不做展开，但最便捷的方式是通过Chrome网上应用店搜索下载，这个操作本身就需要使用代理上网。 配置Proxy SwichyOmega。 首先，新建一个通过代理上网的情景模式。 然后，配置auto switch情景模式。 在规则列表中，输入规则列表网址，并点击“立即更新情景模式”，SwitchyOmega会自动下载规则列表，并在下方显示更新。 1https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 选择AutoProxy 全部配置好以后，如下图所示。 记得配置完成后要点击左下方的“应用选项”，使修改生效。 应用auto switch情景模式]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建自己的github]]></title>
    <url>%2F2018%2F01%2F31%2Fhow%20to%20build%20your%20own%20github%2F</url>
    <content type="text"><![CDATA[建立Git环境关联Github操作技巧1. 为本地库添加远程库现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1$ git remote add origin git@github.com:michaelliao/learngit.git]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有用的技术、工具和站点]]></title>
    <url>%2F2018%2F01%2F31%2Flist%20of%20the%20useful%20tools%20and%20sites%2F</url>
    <content type="text"><![CDATA[（持续更新中…） 站点推荐1. Github2. Library Genesis 在这里可以下载到很多计算机类的电子书，而且都是相对清晰的pdf文档。 云服务系列1. AWS2. 七牛云3. 实用技术1. Markdown2. 思维导图 实用工具1. Typora2. ShadowSocks3. FreeMind4. Anaconda5. 010Editor一款集成了python包的软件，不需要考虑包之间的依赖关系，很方便。 Anaconda官方网站]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>github</tag>
        <tag>实用工具</tag>
        <tag>站点推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo在github上建立自己的博客]]></title>
    <url>%2F2018%2F01%2F30%2Fhowtobuildhexoblogingithub%2F</url>
    <content type="text"><![CDATA[1 建立hexo本地站点具体参考https://hexo.io/主要步骤：1hexo init 1hexo g 1hexo s 默认端口为4000，如果该端口被占用，可以通过hexo s -p 8080将端口改为8080 2 配置主题在https://hexo.io/themes/ 中选择适合自己的主题，并copy到themes文件夹以下以next主题为例 3 配置github自动部署参考https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/主要步骤：修改站点根目录下的_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 民科小屋subtitle: 计算机民科description:author: xiaofengwolanguage: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://ifuleyou.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pageindex_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 15# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:ifuleyou/ifuleyou.github.io.git branch: mastersearch: path: search.xml field: post format: html limit: 10000 4 配置评论、评分、访问计数在themes/next/_config.yml里修改以下配置并且按照配置文件中给出的站点到相应的网站中注册账号，获取相应信息 1234567891011121314151617181920# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: xxxx color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: xxxxx app_key: xxxxxxxx# Disqusdisqus: enable: true shortname: xiaofengwo count: true 5 如何为next主题添加背景效果next主题有一个十分有趣的js背景效果，可以跟随鼠标的移动，汇集背景中随机浮动的点，并在每两个点之间生成一条线段，生生灭灭，聚聚散散，科技感十足，特别受广大民科喜欢。 6 为hexo博客插入图片 七牛云存储 首先，到https://www.qiniu.com网站注册账号，需要实名认证。 然后，创建自己的存储空间。 利用图床软件（windows下的uwp图床，mac下的U图床等）将图片上传到自己的存储空间后，获得url，直接利用url访问即可。 此方法的好处，是操作简便，无需关心图片的具体存放，且七牛会为图片进行瘦身，访问速度较快。另外，图片资源不需要存放到hexo的source文件夹下，可以减少本地存储以及git同步时的时间空间开销，也较易于进行跨越博客平台的迁移。 利用hexo-asset-image上传图片 直接摘抄https://www.jianshu.com/p/c2ba9533088a中的步骤 1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 注意:通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo3的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 [](/example.jpg)，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是markdown ​]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
